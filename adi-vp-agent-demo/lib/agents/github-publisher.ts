import { exec } from 'child_process';
import { promisify } from 'util';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import type { GitHubResult, JDSummary, EmailDraft } from '@/types';

const execAsync = promisify(exec);

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .trim();
}

export async function publishToGitHub(
  companyName: string,
  jdSummary: JDSummary,
  emailDraft: EmailDraft,
  resume: string
): Promise<GitHubResult> {
  // Detect environment
  const isVercel = process.env.VERCEL === '1';
  
  if (isVercel) {
    // TODO: Implement Octokit-based publishing for Vercel
    throw new Error('GitHub publishing on Vercel requires GITHUB_TOKEN and Octokit implementation');
  } else {
    // Local development: use GitHub CLI
    try {
      await execAsync('gh auth status');
    } catch (error) {
      throw new Error('GitHub CLI not authenticated. Run: gh auth login');
    }
    
    // Create folder structure
    const companySlug = slugify(companyName);
    const date = new Date().toISOString().split('T')[0];
    const submissionDir = join(process.cwd(), 'submissions', companySlug);
    
    // Create directory
    await mkdir(submissionDir, { recursive: true });
    
    // Create files
    const files: string[] = [];
    
    // 1. Role Summary
    const summaryPath = join(submissionDir, 'role_summary.md');
    const summaryContent = `# ${companyName} - Role Summary

## Summary
${jdSummary.summary}

## Key Requirements
${jdSummary.key_requirements.map(req => `- ${req}`).join('\n')}

## Company Context
${jdSummary.company_context}

---
*Generated on ${new Date().toLocaleString()}*
`;
    await writeFile(summaryPath, summaryContent);
    files.push(`submissions/${companySlug}/role_summary.md`);
    
    // 2. Email Draft
    const emailPath = join(submissionDir, 'intro_email.md');
    const emailContent = `# Introduction Email

**To:** ${companyName} Hiring Team  
**Subject:** ${emailDraft.subject}

---

${emailDraft.email_body}

---
*Confidence Score: ${(emailDraft.confidence_score * 100).toFixed(0)}%*  
*Generated on ${new Date().toLocaleString()}*
`;
    await writeFile(emailPath, emailContent);
    files.push(`submissions/${companySlug}/intro_email.md`);
    
    // 3. Resume
    const resumePath = join(submissionDir, 'resume.txt');
    await writeFile(resumePath, resume);
    files.push(`submissions/${companySlug}/resume.txt`);
    
    // 4. README for the folder
    const readmePath = join(submissionDir, 'README.md');
    const readmeContent = `# ${companyName} Application

This folder contains my application materials for ${companyName}.

## Contents
- **role_summary.md** - AI-analyzed summary of the job description
- **intro_email.md** - Personalized introduction email
- **resume.txt** - My resume

## Application Details
- **Company:** ${companyName}
- **Applied on:** ${new Date().toLocaleDateString()}
- **Status:** Pending

## Notes
This application was generated using the VP Agent Demo, an AI-powered job application assistant.
`;
    await writeFile(readmePath, readmeContent);
    files.push(`submissions/${companySlug}/README.md`);
    
    // Git operations
    try {
      // Get current repo info
      const { stdout: repoUrl } = await execAsync('gh repo view --json url -q .url');
      const cleanRepoUrl = repoUrl.trim();
      
      // Create a new branch
      const branchName = `submit/${companySlug}-${date}`;
      await execAsync(`git checkout -b ${branchName}`);
      
      // Add files
      await execAsync('git add submissions/');
      
      // Commit
      const commitMessage = `Add application for ${companyName}

- Job description summary
- Personalized introduction email
- Resume
- Application folder README`;
      
      await execAsync(`git commit -m "${commitMessage}"`);
      
      // Push branch
      await execAsync(`git push origin ${branchName}`);
      
      // Create PR
      const prTitle = `Application: ${companyName}`;
      const prBody = `## 🎯 Job Application for ${companyName}

This PR contains my application materials for the position at ${companyName}.

### 📁 Files Included
${files.map(f => `- \`${f}\``).join('\n')}

### 🤖 Generated by VP Agent Demo
This application was automatically generated and organized using AI-powered analysis.

---
*Please review the materials and merge when ready to track this application.*`;
      
      const { stdout: prUrl } = await execAsync(
        `gh pr create --title "${prTitle}" --body "${prBody}" --base main`
      );
      
      // Get commit SHA
      const { stdout: commitSha } = await execAsync('git rev-parse HEAD');
      
      // Switch back to main branch
      await execAsync('git checkout main');
      
      return {
        repo_url: cleanRepoUrl,
        pr_url: prUrl.trim(),
        commit_sha: commitSha.trim().substring(0, 7),
        files_created: files
      };
      
    } catch (error: any) {
      // If git operations fail, still return the local files created
      console.error('Git operations failed:', error);
      return {
        repo_url: 'local',
        pr_url: 'local-only',
        commit_sha: 'local',
        files_created: files
      };
    }
  }
}
